{
  "_args": [
    [
      {
        "raw": "subscriptions-transport-ws@^0.9.11",
        "scope": null,
        "escapedName": "subscriptions-transport-ws",
        "name": "subscriptions-transport-ws",
        "rawSpec": "^0.9.11",
        "spec": ">=0.9.11 <0.10.0",
        "type": "range"
      },
      "C:\\Users\\wardha\\graphql-server-example\\node_modules\\apollo-server-core"
    ]
  ],
  "_from": "subscriptions-transport-ws@^0.9.11",
  "_hasShrinkwrap": false,
  "_id": "subscriptions-transport-ws@0.9.18",
  "_location": "/subscriptions-transport-ws",
  "_nodeVersion": "12.18.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/subscriptions-transport-ws_0.9.18_1597664766449_0.10391269226265831"
  },
  "_npmUser": {
    "name": "apollo-bot",
    "email": "npm@apollographql.com"
  },
  "_npmVersion": "6.14.7",
  "_phantomChildren": {
    "async-limiter": "1.0.1"
  },
  "_requested": {
    "raw": "subscriptions-transport-ws@^0.9.11",
    "scope": null,
    "escapedName": "subscriptions-transport-ws",
    "name": "subscriptions-transport-ws",
    "rawSpec": "^0.9.11",
    "spec": ">=0.9.11 <0.10.0",
    "type": "range"
  },
  "_requiredBy": [
    "/apollo-server-core",
    "/apollo-server-express"
  ],
  "_resolved": "https://registry.npmjs.org/subscriptions-transport-ws/-/subscriptions-transport-ws-0.9.18.tgz",
  "_shasum": "bcf02320c911fbadb054f7f928e51c6041a37b97",
  "_shrinkwrap": null,
  "_spec": "subscriptions-transport-ws@^0.9.11",
  "_where": "C:\\Users\\wardha\\graphql-server-example\\node_modules\\apollo-server-core",
  "browser": "dist/client.js",
  "bugs": {
    "url": "https://github.com/apollostack/subscriptions-transport-ws/issues"
  },
  "contributors": [
    {
      "name": "Authors"
    },
    {
      "name": "Jonas Helfer",
      "email": "helfer@users.noreply.github.com"
    },
    {
      "name": "Jonas Helfer",
      "email": "jonas@helfer.email"
    },
    {
      "name": "Amanda Jin Liu",
      "email": "ajliu72@gmail.com"
    },
    {
      "name": "Robin Ricard",
      "email": "ricard.robin@gmail.com"
    },
    {
      "name": "Sashko Stubailo",
      "email": "s.stubailo@gmail.com"
    },
    {
      "name": "Sashko Stubailo",
      "email": "sashko@stubailo.com"
    },
    {
      "name": "Hagai Cohen",
      "email": "DxCx@users.noreply.github.com"
    },
    {
      "name": "Kamil Kisiela",
      "email": "kamil.kisiela@gmail.com"
    },
    {
      "name": "Francois Valdy",
      "email": "gluck@users.noreply.github.com"
    },
    {
      "name": "Daniel Rinehart",
      "email": "NeoPhi@users.noreply.github.com"
    },
    {
      "name": "Lukas Fittl",
      "email": "lfittl@users.noreply.github.com"
    }
  ],
  "dependencies": {
    "backo2": "^1.0.2",
    "eventemitter3": "^3.1.0",
    "iterall": "^1.2.1",
    "symbol-observable": "^1.0.4",
    "ws": "^5.2.0"
  },
  "description": "A websocket transport for GraphQL subscriptions",
  "devDependencies": {
    "@types/chai": "^4.0.0",
    "@types/graphql": "^14.0.0",
    "@types/is-promise": "^2.1.0",
    "@types/lodash": "^4.14.109",
    "@types/mocha": "^5.2.5",
    "@types/node": "^8.0.8",
    "@types/sinon": "^5.0.1",
    "@types/ws": "^5.1.2",
    "chai": "^4.0.2",
    "graphql": "^15.3.0",
    "graphql-subscriptions": "^1.0.0",
    "istanbul": "^1.0.0-alpha.2",
    "lodash": "^4.17.1",
    "mocha": "^5.2.0",
    "mock-socket-with-protocol": "^7.1.0",
    "remap-istanbul": "^0.11.1",
    "rimraf": "^2.6.1",
    "sinon": "^6.1.4",
    "tslint": "^5.10.0",
    "typescript": "^3.9.6",
    "webpack": "^3.1.0"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-tztzcBTNoEbuErsVQpTN2xUNN/efAZXyCyL5m3x4t6SKrEiTL2N8SaKWBFWM4u56pL79ULif3zjyeq+oV+nOaA==",
    "shasum": "bcf02320c911fbadb054f7f928e51c6041a37b97",
    "tarball": "https://registry.npmjs.org/subscriptions-transport-ws/-/subscriptions-transport-ws-0.9.18.tgz",
    "fileCount": 47,
    "unpackedSize": 268953,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfOm3/CRA9TVsSAnZWagAA3i4P/2w2Hf+kBG3smoISn/8u\nYcwhe1WCtXZNST5jp97tJZytRMuPpahHKpKS86on8rVGZBOAJg7GpELJOrZy\nq1bBRpTDhlFF0XZ62C0FPq7MU5zKI/gAJH5YSrZQHObg2SWZUTAc4GNm8O8U\n01hjZ72CxNvVywQcmHCqvTSc9T+htaPpqueKpkuZ6kz2rlY+FyXD7nv1BvWr\ngojaejaawP8zhYdbY0AaKWg7Egcr6rTQ5gPCh9nK7fB5LR42fMSBEUEKoZzL\nyVr7rqJENNWpUyTP6DKk9H4Bgigd5hVGM9slCl76GmrlhaaWupNGjItDCaqb\nybTldch0CiE5LLKkBwnrV2pi1bEUfqiGgCijkEp40G0UqXth3lxnvA3lKG8z\nUwLOJBwmT4lsPstcb0lrbhWSoHfogo8Gs/0QT7FZxxiBfeWgqyudGBmODWyx\nyOj9MM3HWgHd8ZjgX0ovQhKPDY3TVEzmpcKxodt8HE3kn+q7pkxm3Hk3De+/\nC2UTF+O4ALhjDlNTyBbRwBg0/x7LAmDcmVB8/sKHIoJ78O1BQvGc7U7voKAV\ntS7xOKgTgrTdJUpa5/UfjxBfDqcfYJb/XeJXUWqSenTP7UjIaWiGPE8oQtqB\nmdAmGVQ6KIjuJ3m4x5+/ak4Gf7zNsu+CNsc7nMuyLFG40A+OtShCoUTz5h2w\ns896\r\n=/DyQ\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "gitHead": "4e975e3ed89cb866eb0f28701dabf57baf8099d9",
  "homepage": "https://github.com/apollostack/subscriptions-transport-ws#readme",
  "license": "MIT",
  "main": "dist/index.js",
  "maintainers": [
    {
      "name": "apollo-bot",
      "email": "npm@apollographql.com"
    },
    {
      "name": "danielr",
      "email": "danielr@neophi.com"
    },
    {
      "name": "helfer",
      "email": "jonas@helfer.email"
    },
    {
      "name": "mistic",
      "email": "tiagoffcc@hotmail.com"
    },
    {
      "name": "mxstbr",
      "email": "contact@mxstbr.com"
    },
    {
      "name": "sashko",
      "email": "s.stubailo@gmail.com"
    }
  ],
  "name": "subscriptions-transport-ws",
  "optionalDependencies": {},
  "peerDependencies": {
    "graphql": ">=0.10.0"
  },
  "readme": "[![npm version](https://badge.fury.io/js/subscriptions-transport-ws.svg)](https://badge.fury.io/js/subscriptions-transport-ws) [![GitHub license](https://img.shields.io/github/license/apollostack/subscriptions-transport-ws.svg)](https://github.com/apollostack/subscriptions-transport-ws/blob/license/LICENSE)\n\n# subscriptions-transport-ws\n\n**(Work in progress!)**\n\nA GraphQL WebSocket server and client to facilitate GraphQL queries, mutations and subscriptions over WebSocket.\n\n> `subscriptions-transport-ws` is an extension for GraphQL, and you can use it with any GraphQL client and server (not only Apollo).\n\nSee [GitHunt-API](https://github.com/apollostack/GitHunt-API) and [GitHunt-React](https://github.com/apollostack/GitHunt-React) for an example server and client integration.\n\n# Getting Started\n\nStart by installing the package, using Yarn or NPM.\n\n    Using Yarn:\n    $ yarn add subscriptions-transport-ws\n\n    Or, using NPM:\n    $ npm install --save subscriptions-transport-ws\n\n> Note that you need to use this package on both GraphQL client and server.\n\n> This command also installs this package's dependencies, including `graphql-subscriptions`.\n\n## Server\n\nStarting with the server, create a new simple `PubSub` instance. We will later use this `PubSub` to publish and subscribe to data changes.\n\n```js\nimport { PubSub } from 'graphql-subscriptions';\n\nexport const pubsub = new PubSub();\n```\n\nNow, create `SubscriptionServer` instance, with your GraphQL `schema`, `execute` and `subscribe` (from `graphql-js` package):\n\n```js\nimport { createServer } from 'http';\nimport { SubscriptionServer } from 'subscriptions-transport-ws';\nimport { execute, subscribe } from 'graphql';\nimport { schema } from './my-schema';\n\nconst WS_PORT = 5000;\n\n// Create WebSocket listener server\nconst websocketServer = createServer((request, response) => {\n  response.writeHead(404);\n  response.end();\n});\n\n// Bind it to port and start listening\nwebsocketServer.listen(WS_PORT, () => console.log(\n  `Websocket Server is now running on http://localhost:${WS_PORT}`\n));\n\nconst subscriptionServer = SubscriptionServer.create(\n  {\n    schema,\n    execute,\n    subscribe,\n  },\n  {\n    server: websocketServer,\n    path: '/graphql',\n  },\n);\n```\n\n### Creating Your Subscriptions\n\nPlease refer to [`graphql-subscriptions`](https://github.com/apollographql/graphql-subscriptions) documentation for how to create your GraphQL subscriptions, and how to publish data.\n\n\n\n## Client (browser)\n\nWhen using this package for client side, you can choose either use HTTP request for Queries and Mutation and use the WebSocket for subscriptions only, or create a full transport that handles all type of GraphQL operations over the socket.\n\n### Full WebSocket Transport\n\nTo start with a full WebSocket transport, that handles all types of GraphQL operations, import and create an instance of `SubscriptionClient`.\n\nThen, create your `ApolloClient` instance and use the `SubscriptionsClient` instance as network interface:\n\n```js\nimport { SubscriptionClient } from 'subscriptions-transport-ws';\nimport ApolloClient from 'apollo-client';\n\nconst GRAPHQL_ENDPOINT = 'ws://localhost:3000/graphql';\n\nconst client = new SubscriptionClient(GRAPHQL_ENDPOINT, {\n  reconnect: true,\n});\n\nconst apolloClient = new ApolloClient({\n    networkInterface: client,\n});\n\n```\n\n### Hybrid WebSocket Transport\n\nTo start with a hybrid WebSocket transport, that handles only `subscription`s over WebSocket, create your `SubscriptionClient` and a regular HTTP network interface, then extend your network interface to use the WebSocket client for GraphQL subscriptions:\n\n```js\nimport {SubscriptionClient, addGraphQLSubscriptions} from 'subscriptions-transport-ws';\nimport ApolloClient, {createNetworkInterface} from 'apollo-client';\n\n// Create regular NetworkInterface by using apollo-client's API:\nconst networkInterface = createNetworkInterface({\n uri: 'http://localhost:3000' // Your GraphQL endpoint\n});\n\n// Create WebSocket client\nconst wsClient = new SubscriptionClient(`ws://localhost:5000/`, {\n    reconnect: true,\n    connectionParams: {\n        // Pass any arguments you want for initialization\n    }\n});\n\n// Extend the network interface with the WebSocket\nconst networkInterfaceWithSubscriptions = addGraphQLSubscriptions(\n    networkInterface,\n    wsClient\n);\n\n// Finally, create your ApolloClient instance with the modified network interface\nconst apolloClient = new ApolloClient({\n    networkInterface: networkInterfaceWithSubscriptions\n});\n```\n\nNow, when you want to use subscriptions in client side, use your `ApolloClient` instance, with [`subscribe`](https://www.apollographql.com/docs/react/api/apollo-client#ApolloClient.subscribe) or `query` [`subscribeToMore`](https://www.apollographql.com/docs/react/api/apollo-client#ObservableQuery.subscribeToMore):\n\n```js\napolloClient.subscribe({\n  query: gql`\n    subscription onNewItem {\n        newItemCreated {\n            id\n        }\n    }`,\n  variables: {}\n}).subscribe({\n  next (data) {\n    // Notify your application with the new arrived data\n  }\n});\n```\n\n```js\napolloClient.query({\n  query: ITEM_LIST_QUERY,\n  variables: {}\n}).subscribeToMore({\n  document: gql`\n    subscription onNewItem {\n        newItemCreated {\n            id\n        }\n    }`,\n  variables: {},\n  updateQuery: (prev, { subscriptionData, variables }) => {\n    // Perform updates on previousResult with subscriptionData\n    return updatedResult;\n  }\n});\n```\n\nIf you don't use any package/modules loader, you can still use this package, by using `unpkg` service, and get the client side package from:\n\n```\nhttps://unpkg.com/subscriptions-transport-ws@VERSION/browser/client.js\n```\n\n> Replace VERSION with the latest version of the package.\n\n\n## Use it with GraphiQL\n\nYou can use this package's power with GraphiQL, and subscribe to live-data stream inside GraphiQL.\n\nIf you are using the latest version of `graphql-server` flavors (`graphql-server-express`, `graphql-server-koa`, etc...), you already can use it! Make sure to specify `subscriptionsEndpoint` in GraphiQL configuration, and that's it!\n\nFor example, `graphql-server-express` users need to add the following:\n\n```js\napp.use('/graphiql', graphiqlExpress({\n  endpointURL: '/graphql',\n  subscriptionsEndpoint: `YOUR_SUBSCRIPTION_ENDPOINT_HERE`,\n}));\n```\n\nIf you are using older version, or another GraphQL server, start by modifying GraphiQL static HTML, and add this package and it's fetcher from CDN:\n\n```html\n    <script src=\"//unpkg.com/subscriptions-transport-ws@0.5.4/browser/client.js\"></script>\n    <script src=\"//unpkg.com/graphiql-subscriptions-fetcher@0.0.2/browser/client.js\"></script>\n```\n\nThen, create `SubscriptionClient` and define the fetcher:\n\n```js\nlet subscriptionsClient = new window.SubscriptionsTransportWs.SubscriptionClient('SUBSCRIPTION_WS_URL_HERE', {\n  reconnect: true\n});\nlet myCustomFetcher = window.GraphiQLSubscriptionsFetcher.graphQLFetcher(subscriptionsClient, graphQLFetcher);\n```\n\n> `graphQLFetcher` is the default fetcher, and we use it as fallback for non-subscription GraphQL operations.\n\nAnd replace your GraphiQL creation logic to use the new fetcher:\n\n```js\nReactDOM.render(\n  React.createElement(GraphiQL, {\n    fetcher: myCustomFetcher, // <-- here\n    onEditQuery: onEditQuery,\n    onEditVariables: onEditVariables,\n    onEditOperationName: onEditOperationName,\n    query: ${safeSerialize(queryString)},\n    response: ${safeSerialize(resultString)},\n    variables: ${safeSerialize(variablesString)},\n    operationName: ${safeSerialize(operationName)},\n  }),\n  document.body\n);\n```\n\n# API Docs\n\n## SubscriptionClient\n### `Constructor(url, options, webSocketImpl)`\n- `url: string` : url that the client will connect to, starts with `ws://` or `wss://`\n- `options?: Object` : optional, object to modify default client behavior\n  * `timeout?: number` : how long the client should wait in ms for a keep-alive message from the server (default 30000 ms), this parameter is ignored if the server does not send keep-alive messages. This will also be used to calculate the max connection time per connect/reconnect\n  * `minTimeout?: number`: the minimum amount of time the client should wait for a connection to be made (default 1000 ms)\n  * `lazy?: boolean` : use to set lazy mode - connects only when first subscription created, and delay the socket initialization\n  * `connectionParams?: Object | Function | Promise<Object>` : object that will be available as first argument of `onConnect` (in server side), if passed a function - it will call it and send the return value, if function returns as promise - it will wait until it resolves and send the resolved value.\n  * `reconnect?: boolean` : automatic reconnect in case of connection error\n  * `reconnectionAttempts?: number` : how much reconnect attempts\n  * `connectionCallback?: (error) => {}` : optional, callback that called after the first init message, with the error (if there is one)\n  * `inactivityTimeout?: number` : how long the client should wait in ms, when there are no active subscriptions, before disconnecting from the server. Set to 0 to disable this behavior. (default 0)\n- `webSocketImpl?: Object` - optional, constructor for W3C compliant WebSocket implementation. Use this when your environment does not have a built-in native WebSocket (for example, with NodeJS client)\n\n### Methods\n#### `request(options) => Observable<ExecutionResult>`: returns observable to execute the operation.\n- `options: {OperationOptions}`\n  * `query: string` : GraphQL subscription\n  * `variables: Object` : GraphQL subscription variables\n  * `operationName: string` : operation name of the subscription\n  * `context: Object` : use to override context for a specific call\n\n#### `unsubscribeAll() => void` - unsubscribes from all active subscriptions.\n\n#### `on(eventName, callback, thisContext) => Function`\n- `eventName: string`: the name of the event, available events are: `connecting`, `connected`, `reconnecting`, `reconnected`, `disconnected` and `error`\n- `callback: Function`: function to be called when websocket connects and initialized.\n- `thisContext: any`: `this` context to use when calling the callback function.\n- => Returns an `off` method to cancel the event subscription.\n\n#### `onConnected(callback, thisContext) => Function` - shorthand for `.on('connected', ...)`\n- `callback: Function(payload)`: function to be called when websocket connects and initialized, after ACK message returned from the server. Includes payload from server, if any.\n- `thisContext: any`: `this` context to use when calling the callback function.\n- => Returns an `off` method to cancel the event subscription.\n\n#### `onReconnected(callback, thisContext) => Function` - shorthand for `.on('reconnected', ...)`\n- `callback: Function(payload)`: function to be called when websocket reconnects and initialized, after ACK message returned from the server. Includes payload from server, if any.\n- `thisContext: any`: `this` context to use when calling the callback function.\n- => Returns an `off` method to cancel the event subscription.\n\n#### `onConnecting(callback, thisContext) => Function` - shorthand for `.on('connecting', ...)`\n- `callback: Function`: function to be called when websocket starts it's connection\n- `thisContext: any`: `this` context to use when calling the callback function.\n- => Returns an `off` method to cancel the event subscription.\n\n#### `onReconnecting(callback, thisContext) => Function` - shorthand for `.on('reconnecting', ...)`\n- `callback: Function`: function to be called when websocket starts it's reconnection\n- `thisContext: any`: `this` context to use when calling the callback function.\n- => Returns an `off` method to cancel the event subscription.\n\n#### `onDisconnected(callback, thisContext) => Function` - shorthand for `.on('disconnected', ...)`\n- `callback: Function`: function to be called when websocket disconnected.\n- `thisContext: any`: `this` context to use when calling the callback function.\n- => Returns an `off` method to cancel the event subscription.\n\n#### `onError(callback, thisContext) => Function` - shorthand for `.on('error', ...)`\n- `callback: Function`: function to be called when an error occurs.\n- `thisContext: any`: `this` context to use when calling the callback function.\n- => Returns an `off` method to cancel the event subscription.\n\n### `close() => void` - closes the WebSocket connection manually, and ignores `reconnect` logic if it was set to `true`.\n\n### `use(middlewares: MiddlewareInterface[]) => SubscriptionClient` - adds middleware to modify `OperationOptions` per each request\n- `middlewares: MiddlewareInterface[]` - Array contains list of middlewares (implemented `applyMiddleware` method) implementation, the `SubscriptionClient` will use the middlewares to modify `OperationOptions` for every operation\n\n### `status: number` : returns the current socket's `readyState`\n\n\n## SubscriptionServer\n### `Constructor(options, socketOptions | socketServer)`\n- `options: {ServerOptions}`\n  * `rootValue?: any` : Root value to use when executing GraphQL root operations\n  * `schema?: GraphQLSchema` : GraphQL schema object. If not provided, you have to return the schema as a property on the object returned from `onOperation`.\n  * `execute?: (schema, document, rootValue, contextValue, variableValues, operationName) => Promise<ExecutionResult> | AsyncIterator<ExecutionResult>` : GraphQL `execute` function, provide the default one from `graphql` package. Return value of `AsyncItrator` is also valid since this package also support reactive `execute` methods.\n  * `subscribe?: (schema, document, rootValue, contextValue, variableValues, operationName) => Promise<ExecutionResult | AsyncIterator<ExecutionResult>>` : GraphQL `subscribe` function, provide the default one from `graphql` package.\n  * `onOperation?: (message: SubscribeMessage, params: ExecutionParams, webSocket: WebSocket)` : optional method to create custom params that will be used when resolving this operation. It can also be used to dynamically resolve the schema that will be used for the particular operation.\n  * `onOperationComplete?: (webSocket: WebSocket, opId: string)` : optional method that called when a GraphQL operation is done (for query and mutation it's immediately, and for subscriptions when unsubscribing)\n  * `onConnect?: (connectionParams: Object, webSocket: WebSocket, context: ConnectionContext)` : optional method that called when a client connects to the socket, called with the `connectionParams` from the client, if the return value is an object, its elements will be added to the context. return `false` or throw an exception to reject the connection. May return a Promise.\n  * `onDisconnect?: (webSocket: WebSocket, context: ConnectionContext)` : optional method that called when a client disconnects\n  * `keepAlive?: number` : optional interval in ms to send `KEEPALIVE` messages to all clients\n\n- `socketOptions: {WebSocket.IServerOptions}` : options to pass to the WebSocket object (full docs [here](https://github.com/websockets/ws/blob/master/doc/ws.md))\n  * `server?: HttpServer` - existing HTTP server to use (use without `host`/`port`)\n  * `host?: string` - server host\n  * `port?: number` - server port\n  * `path?: string` - endpoint path\n\n- `socketServer: {WebSocket.Server}` : a configured server if you need more control. Can be used for integration testing with in-memory WebSocket implementation.\n\n## How it works?\n\n* For GraphQL WebSocket protocol docs, [click here](https://github.com/apollographql/subscriptions-transport-ws/blob/master/PROTOCOL.md)\n* This package also uses `AsyncIterator` internally using [iterall](https://github.com/leebyron/iterall), for more information [click here](https://github.com/ReactiveX/IxJS), or [the proposal](https://github.com/tc39/proposal-async-iteration)\n\nThe current version of this transport, also support a previous version of the protocol.\n\n[You can find the old protocol docs here](https://github.com/apollographql/subscriptions-transport-ws/blob/cacb8692f3601344a4101d802443d046d73f8b23/README.md#client-server-communication)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/apollostack/subscriptions-transport-ws.git"
  },
  "scripts": {
    "browser-compile": "webpack --config \"./unpkg-webpack.config.js\"",
    "clean": "rimraf browser dist coverage",
    "compile": "tsc",
    "coverage": "node ./node_modules/istanbul/lib/cli.js cover _mocha -- --exit --full-trace ./dist/test/tests.js",
    "lint": "tslint --format stylish --project ./tsconfig.json",
    "postcoverage": "remap-istanbul --input coverage/coverage.raw.json --type lcovonly --output coverage/lcov.info",
    "posttest": "npm run lint",
    "prepublishOnly": "npm run clean && npm run compile && npm run browser-compile",
    "pretest": "npm run compile",
    "test": "npm run testonly --",
    "testonly": "mocha --exit --reporter spec --full-trace ./dist/test/**/*.js",
    "watch": "tsc -w"
  },
  "typescript": {
    "definition": "dist/index.d.ts"
  },
  "typings": "dist/index.d.ts",
  "version": "0.9.18"
}
